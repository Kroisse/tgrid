import { Tabs, Tab } from 'nextra-theme-docs'
import Alert from '@mui/material/Alert';
import AlertTitle from '@mui/material/AlertTitle';

## Outline
This chapter describes key components of the `TGrid` only in the conceptual level.

If you're not familar with theoretical stories, it's okay to skip to the next chapter [Features > WebSocket Protocol](./websocket).

Otherwise, let's study about the key components of the `TGrid`.

  - [`Communicator`](#communicator): network communication with remote system
  - [`Provider`](#provider): object provided for remote system
  - [`Listener`](#listener): interface of the remote system's `Provider`
  - [`Driver`](#driver): proxy instance for calling functions of the remote system's `Provider`




## Communicator
![Sequence Diagram](/images/diagrams/sequence.png)

Communicates with a remote system.

`Communicator` is a class taking full responsibility to network communication with remote system. You can register a Provider, an object would be provided to the remote system, to the `Communicator`. Also, [Driver](#driver)\<[Listener](#listener)\>, which can access to the remote system's [Provider](#provider), is created by this `Communicator`.

For reference, actual `Communicator` is the top-level abstract class, and all the classes responsible for network communication in `TGrid` are inheriting from this `Communicator` class. Here is the list of every communicator classes in `TGrid`.

Protocol | Client | Server
---------|--------|--------
Web Socket | [`WebSocketConnector`](./websocket/#websocketconnector) | [`WebSocketAcceptor`](./websocket/#websocketacceptor)
Dedicated Worker | [`WorkerConnector`](./worker/#workerconnector) | [`WorkerServer`](./worker/#workerserver)
Shared Worker | [`SharedWorkerConnector`](./worker/#sharedworkerconnector) | [`SharedWorkerAcceptor`](./worker/#sharedworkeracceptor)




## Provider
Object provided for remote system.

`Provider` is an object provided for the remote system.

The remote system can call the `Provider`'s functions through [Driver](#driver)\<[Listener](#listener)\>.

```typescript filename="examples/websocket/server.ts" showLineNumbers
import { Driver, WebSocketServer } from "tgrid";

import { ICalcConfig } from "../interfaces/ICalcConfig";
import { ICalcEventListener } from "../interfaces/ICalcEventListener";
import { CompositeCalculator } from "../providers/CompositeCalculator";
import { ScientificCalculator } from "../providers/ScientificCalculator";
import { SimpleCalculator } from "../providers/SimpleCalculator";
import { StatisticsCalculator } from "../providers/StatisticsCalculator";

export const webSocketServerMain = async () => {
  const server: WebSocketServer<
    ICalcConfig, // header
    // providers
    | CompositeCalculator
    | SimpleCalculator
    | StatisticsCalculator
    | ScientificCalculator,
    ICalcEventListener // listener
  > = new WebSocketServer();
  await server.open(37_000, async (acceptor) => {
    // LIST UP PROPERTIES
    const config: ICalcConfig = acceptor.header;
    const listener: Driver<ICalcEventListener> = acceptor.getDriver();

    // ACCEPT OR REJECT
    if (acceptor.path === "/composite")
      await acceptor.accept(new CompositeCalculator(config, listener));
    else if (acceptor.path === "/simple")
      await acceptor.accept(new SimpleCalculator(config, listener));
    else if (acceptor.path === "/statistics")
      await acceptor.accept(new StatisticsCalculator(config, listener));
    else if (acceptor.path === "/scientific")
      await acceptor.accept(new ScientificCalculator(config, listener));
    else await acceptor.reject(1002, `WebSocket API endpoint not found.`);
  });
  return server;
};
```



## Listener
Interface of the remote system's [Provider](#provider).

`Listener` is a type definition (interface is recommended) of the remote system's [Provider](#provider). If you wrap the `Listener` type into the [Driver](#driver)\<`Listener`\> through `Communicator.getDriver<Listener>()` method, you can call the functions of the remote system's [Provider](#provider) asynchronously.

For reference, it is possible to using the original [Provider](#provider) type of the remote system, so that composing [Driver](#driver)\<[Provider](#provider)\> type. However, such way is not recommended due to the dependency problem. Instead, consider to defining the [Provider](#provider) class to implement the `Listener` interface type.




## Driver
```typescript filename="examples/websocket/client.ts" showLineNumbers
import { Driver, WebSocketConnector } from "tgrid";

import { ICalcConfig } from "../interfaces/ICalcConfig";
import { ICalcEvent } from "../interfaces/ICalcEvent";
import { ICalcEventListener } from "../interfaces/ICalcEventListener";
import { ICompositeCalculator } from "../interfaces/ICompositeCalculator";

export const webSocketClientMain = async () => {
  const stack: ICalcEvent[] = [];
  const listener: ICalcEventListener = {
    on: (evt: ICalcEvent) => stack.push(evt),
  };
  const connector: WebSocketConnector<
    ICalcConfig,
    ICalcEventListener,
    ICompositeCalculator
  > = new WebSocketConnector(
    { precision: 2 }, // header
    listener, // provider for remote server
  );
  await connector.connect("ws://127.0.0.1:37000/composite");

  const remote: Driver<ICompositeCalculator> = connector.getDriver();
  console.log(
    await driver.plus(10, 20), // returns 30
    await driver.multiplies(3, 4), // returns 12
    await driver.divides(5, 3), // returns 1.67
    await driver.scientific.sqrt(2), // returns 1.41
    await driver.statistics.mean(1, 3, 9), // returns 4.33
  );

  await connector.close();
  console.log(stack);
};
```

> ```bash filename="Terminal"
> $ npx ts-node examples/src/websocket
> 30 12 1.67 1.41 4.33
> [
>   { type: 'plus', input: [ 10, 20 ], output: 30 },
>   { type: 'multiplies', input: [ 3, 4 ], output: 12 },
>   { type: 'divides', input: [ 5, 3 ], output: 1.67 },
>   { type: 'sqrt', input: [ 2 ], output: 1.41 },
>   { type: 'mean', input: [ 1, 3, 9 ], output: 4.33 }
> ]
> ```

Driver of Listener for RPC (Remote Procedure Call).

`Driver` is a proxy instance designed to call functions of the remote system. It has a generic argument [Listener](#listener) which means the type of remote system's [Provider](#provider), and you can remotely call the functions of the [Listener](#listener) asynchronously through the `Drive<Listener>` instance.

When you call some function of [Listener](#listener) by the `Driver<Listener>` instance, it hooks the function call expression, and delivers the function name and arguments to the remote system through the [Communicator](#communicator). If the remote system suceeded to reply the result of the function call, [Communicator](#communicator) resolves the promise of the function call expression with the result, so that makes `Driver<Listener>` working.

Otherwise exception is thrown in the [Provider](#provider) function, [Communicator](#communicator) deliveries the exception instance instead to the remote system, so that actual exception being thrown from the `Driver<Listener>` instance.