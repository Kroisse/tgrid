import { Tabs, Tab } from 'nextra-theme-docs'
import Alert from '@mui/material/Alert';
import AlertTitle from '@mui/material/AlertTitle';

## Outline
This chapter describes key components of the `TGrid` only in the conceptual level.

If you're not familar with theoretical stories, it's okay to skip to the next chapter [Features > WebSocket Protocol](./websocket).

Otherwise, let's study about the key components of the `TGrid`.

  - [`Communicator`](#communicator): network communication with remote system
  - [`Provider`](#provider): object provided for remote system
  - [`Driver`](#driver): proxy instance for calling functions of the remote system's `Provider`




## Communicator
![Sequence Diagram](/images/diagrams/sequence.png)

Communicates with a remote system.

`Communicator` is a class taking full responsibility to network communication with remote system. You can register a Provider, an object would be provided to the remote system, to the `Communicator`. Also, [`Driver<Remote>`](#driver), which can access to the remote system's [Provider](#provider), is created by this `Communicator`.

For reference, actual `Communicator` is the top-level abstract class, and all the classes responsible for network communication in `TGrid` are inheriting from this `Communicator` class. Here is the list of every communicator classes in `TGrid`.

Protocol | Client | Server
---------|--------|--------
Web Socket | [`WebSocketConnector`](./websocket/#websocketconnector) | [`WebSocketAcceptor`](./websocket/#websocketacceptor)
Dedicated Worker | [`WorkerConnector`](./worker/#workerconnector) | [`WorkerServer`](./worker/#workerserver)
Shared Worker | [`SharedWorkerConnector`](./worker/#sharedworkerconnector) | [`SharedWorkerAcceptor`](./worker/#sharedworkeracceptor)




## Provider
Object provided for remote system.

`Provider` is an object provided for the remote system.

The remote system can call the `Provider`'s functions through [`Driver<Remote>`](#driver).

```typescript filename="examples/websocket/server.ts" showLineNumbers {22-23, 26-33}
import { Driver, WebSocketServer } from "tgrid";

import { ICalcConfig } from "../interfaces/ICalcConfig";
import { ICalcEventListener } from "../interfaces/ICalcEventListener";
import { CompositeCalculator } from "../providers/CompositeCalculator";
import { ScientificCalculator } from "../providers/ScientificCalculator";
import { SimpleCalculator } from "../providers/SimpleCalculator";
import { StatisticsCalculator } from "../providers/StatisticsCalculator";

export const webSocketServerMain = async () => {
  const server: WebSocketServer<
    ICalcConfig, // header
    // providers
    | CompositeCalculator
    | SimpleCalculator
    | StatisticsCalculator
    | ScientificCalculator,
    ICalcEventListener // listener
  > = new WebSocketServer();
  await server.open(37_000, async (acceptor) => {
    // LIST UP PROPERTIES
    const header: ICalcConfig = acceptor.header;
    const listener: Driver<ICalcEventListener> = acceptor.getDriver();

    // ACCEPT OR REJECT
    if (acceptor.path === "/composite")
      await acceptor.accept(new CompositeCalculator(header, listener));
    else if (acceptor.path === "/simple")
      await acceptor.accept(new SimpleCalculator(header, listener));
    else if (acceptor.path === "/statistics")
      await acceptor.accept(new StatisticsCalculator(header, listener));
    else if (acceptor.path === "/scientific")
      await acceptor.accept(new ScientificCalculator(header, listener));
    else await acceptor.reject(1002, `WebSocket API endpoint not found.`);
  });
  return server;
};
```




## Driver
```typescript filename="examples/websocket/client.ts" showLineNumbers {23-30}
import { Driver, WebSocketConnector } from "tgrid";

import { ICalcConfig } from "../interfaces/ICalcConfig";
import { ICalcEvent } from "../interfaces/ICalcEvent";
import { ICalcEventListener } from "../interfaces/ICalcEventListener";
import { ICompositeCalculator } from "../interfaces/ICompositeCalculator";

export const webSocketClientMain = async () => {
  const stack: ICalcEvent[] = [];
  const listener: ICalcEventListener = {
    on: (evt: ICalcEvent) => stack.push(evt),
  };
  const connector: WebSocketConnector<
    ICalcConfig,
    ICalcEventListener,
    ICompositeCalculator
  > = new WebSocketConnector(
    { precision: 2 }, // header
    listener, // provider for remote server
  );
  await connector.connect("ws://127.0.0.1:37000/composite");

  const remote: Driver<ICompositeCalculator> = connector.getDriver();
  console.log(
    await driver.plus(10, 20), // returns 30
    await driver.multiplies(3, 4), // returns 12
    await driver.divides(5, 3), // returns 1.67
    await driver.scientific.sqrt(2), // returns 1.41
    await driver.statistics.mean(1, 3, 9), // returns 4.33
  );

  await connector.close();
  console.log(stack);
};
```

> ```bash filename="Terminal"
> $ npx ts-node examples/src/websocket
> 30 12 1.67 1.41 4.33
> [
>   { type: 'plus', input: [ 10, 20 ], output: 30 },
>   { type: 'multiplies', input: [ 3, 4 ], output: 12 },
>   { type: 'divides', input: [ 5, 3 ], output: 1.67 },
>   { type: 'sqrt', input: [ 2 ], output: 1.41 },
>   { type: 'mean', input: [ 1, 3, 9 ], output: 4.33 }
> ]
> ```

Driver of RPC (Remote Procedure Call).

`Driver` is a proxy instance designed to call functions of the remote system. It has a generic argument `Remote` which means the type of remote system's [Provider](#provider), and you can remotely call the functions of the [Provider](#provider) asynchronously through the `Drive<Remote>` instance.

When you call some function of remote [Provider](#provider) by the `Driver<Listener>` instance, it hooks the function call expression, and delivers the function name and arguments (parameter values) to the remote system through the [Communicator](#communicator). If the remote system suceeded to reply the result of the function call, [Communicator](#communicator) resolves the promise of the function call expression with the result, so that makes `Driver<Remote>` working.

Otherwise exception is thrown in the remote [Provider](#provider) function, [Communicator](#communicator) deliveries the exception instance instead to the remote system, so that actual exception being thrown from the `Driver<Remote>` instance.