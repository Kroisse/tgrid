import { Callout, Tabs, Tab } from 'nextra-theme-docs'

## Outline
`TGrid` supports WebSocket protocol.

With `TGrid`, you can easily develop WebSocket system under the RPC (Remote Procedure Call) concept.

By the way, when you're developing WebSocket server natively only with `TGrid`, you have to construct and open the WebSocket server through [WebSocketServer](#websocketserver) class. Also, you have to access to the WebSocket server with manual [WebSocketConnector](#websocketconnector) composition.

Instead, if you develop the WebSocket server with `NestJS`, client can easily interact with the WebSocket server by SDK (Software Development Kit) library generated by `Nestia`. Also, you can add HTTP protocol operations to the WebSocket server with `NestJS`'s HTTP controller.

Therefore, when you develop WebSocket server, I recommend to use `NestJS` with `TGrid` for the best development experience.




## Native Classes
### `WebSocketServer`
<Tabs items={["Main Program", "Providers", "Interfaces"]}>
  <Tab>
```typescript filename="examples/websocket/server.ts" showLineNumbers
import { Driver, WebSocketServer } from "tgrid";

import { ICalcConfig } from "../interfaces/ICalcConfig";
import { ICalcEventListener } from "../interfaces/ICalcEventListener";
import { CompositeCalculator } from "../providers/CompositeCalculator";
import { ScientificCalculator } from "../providers/ScientificCalculator";
import { SimpleCalculator } from "../providers/SimpleCalculator";
import { StatisticsCalculator } from "../providers/StatisticsCalculator";

export const webSocketServerMain = async () => {
  const server: WebSocketServer<
    ICalcConfig,
    | CompositeCalculator
    | SimpleCalculator
    | StatisticsCalculator
    | ScientificCalculator,
    ICalcEventListener
  > = new WebSocketServer();
  await server.open(37_000, async (acceptor) => {
    // LIST UP PROPERTIES
    const config: ICalcConfig = acceptor.header;
    const listener: Driver<ICalcEventListener> = acceptor.getDriver();

    // ACCEPT OR REJECT
    if (acceptor.path === "/composite")
      await acceptor.accept(new CompositeCalculator(config, listener));
    else if (acceptor.path === "/simple")
      await acceptor.accept(new SimpleCalculator(config, listener));
    else if (acceptor.path === "/statistics")
      await acceptor.accept(new StatisticsCalculator(config, listener));
    else if (acceptor.path === "/scientific")
      await acceptor.accept(new ScientificCalculator(config, listener));
    else await acceptor.reject(1002, `WebSocket API endpoint not found.`);
  });
  return server;
};
```
  </Tab>
  <Tab>
```typescript filename="examples/src/providers/*.ts" showLineNumbers
import { Driver } from "tgrid";

import { ICalcConfig } from "../interfaces/ICalcConfig";
import { ICalcEventListener } from "../interfaces/ICalcEventListener";
import { ICompositeCalculator } from "../interfaces/ICompositeCalculator";
import { IScientificCalculator } from "../interfaces/IScientificCalculator";
import { ISimpleCalculator } from "../interfaces/ISimpleCalculator";
import { IStatisticsCalculator } from "../interfaces/IStatisticsCalculator";

export abstract class CalculatorBase {
  public constructor(
    private readonly config: ICalcConfig,
    private readonly listener: Driver<ICalcEventListener>,
  ) {}

  protected compute(type: string, input: number[], output: number): number {
    const pow: number = Math.pow(10, this.config.precision);
    output = Math.round(output * pow) / pow;
    this.listener.on({ type, input, output }).catch(() => {});
    return output;
  }
}

export class SimpleCalculator
  extends CalculatorBase
  implements ISimpleCalculator
{
  public plus(x: number, y: number): number {
    return this.compute("plus", [x, y], x + y);
  }
  public minus(x: number, y: number): number {
    return this.compute("minus", [x, y], x - y);
  }
  public multiplies(x: number, y: number): number {
    return this.compute("multiplies", [x, y], x * y);
  }
  public divides(x: number, y: number): number {
    return this.compute("divides", [x, y], x / y);
  }
}

export class ScientificCalculator
  extends CalculatorBase
  implements IScientificCalculator
{
  public pow(x: number, y: number): number {
    return this.compute("pow", [x, y], Math.pow(x, y));
  }
  public sqrt(x: number): number {
    return this.compute("sqrt", [x], Math.sqrt(x));
  }
  public log(x: number, base: number): number {
    return this.compute("log", [x, base], Math.log(x) / Math.log(base));
  }
}

export class StatisticsCalculator
  extends CalculatorBase
  implements IStatisticsCalculator
{
  public mean(...values: number[]): number {
    const sum: number = values.reduce((x, y) => x + y);
    return this.compute("mean", values, sum / values.length);
  }
  public stdev(...values: number[]): number {
    const mean: number = values.reduce((x, y) => x + y) / values.length;
    const sum: number = values.reduce((x, y) => x + Math.pow(y - mean, 2));
    return this.compute("stdev", values, Math.sqrt(sum / values.length));
  }
}

export class CompositeCalculator
  extends SimpleCalculator
  implements ICompositeCalculator
{
  public readonly scientific: ScientificCalculator;
  public readonly statistics: StatisticsCalculator;

  public constructor(
    config: ICalcConfig,
    listener: Driver<ICalcEventListener>,
  ) {
    super(config, listener);
    this.scientific = new ScientificCalculator(config, listener);
    this.statistics = new StatisticsCalculator(config, listener);
  }
}
```
  </Tab>
  <Tab>
```typescript filename="examples/src/interfaces/*.ts" showLineNumbers
export interface ICalcConfig {
  precision: number;
}
export interface ICalcEvent {
  type: string;
  input: number[];
  output: number;
}
export interface ICalcEventListener {
  on(event: ICalcEvent): void;
}

export interface ICompositeCalculator extends ISimpleCalculator {
  scientific: IScientificCalculator;
  statistics: IStatisticsCalculator;
}
export interface ISimpleCalculator {
  plus(x: number, y: number): number;
  minus(x: number, y: number): number;
  multiplies(x: number, y: number): number;
  divides(x: number, y: number): number;
}
export interface IScientificCalculator {
  pow(x: number, y: number): number;
  sqrt(x: number): number;
  log(x: number, base: number): number;
}
export interface IStatisticsCalculator {
  mean(...values: number[]): number;
  stdev(...values: number[]): number;
}
```
  </Tab>
</Tabs>

<Callout type="warning">
  Available only in the NodeJS.
</Callout>

`WebSocketServer` is a class which can open an websocket server. [Clients](#websocketconnector) connecting to the `WebSocketServer` would communicate with this websocket server through [`WebSocketAcceptor`](#websocketacceptor) objects with RPC (Remote Procedure Call) concept.

To open the websocket server, call the [`WebSocketServer.open()`](/api/classes/WorkerServer-1.html#open) method with target port number, and your custom callback function which would be called whenever a [`WebSocketAcceptor`](#websocketacceptor) has been newly created by a new client's connection.

Also, when declaring `WebSocketServer` type, you have to specify three generic arguments; `Header`, `Provider` and `Remote`. Those generic arguments would be propagated to the [`WebSocketAcceptor`](#websocketacceptor), so that [`WebSocketAcceptor`](#websocketacceptor) would have the same generic arguments, too.

For reference, the first `Header` type repersents an initial data from the remote client after the connection. I recommend utilize it as an activation tool for security enhancement. The second generic argument `Provider` represents a provider from server to client, and the other `Remote` means a provider from the remote client to server.

  - Above example case:
    - `Header`: `ICalcConfig` type
    - `Provider`: Server is providing one of below to the client
      - `SimpleCalculator`
      - `StatisticsCalculator`
      - `ScientificCalculator`
    - `Remote`: Client is providing `ICalcEventListener` to the server

### `WebSocketAcceptor`
<Tabs items={["Main Program", "Providers", "Interfaces"]}>
  <Tab>
```typescript filename="examples/src/websocket/server.ts" showLineNumbers {21-45}
import { Driver, WebSocketAcceptor, WebSocketServer } from "tgrid";

import { ICalcConfig } from "../interfaces/ICalcConfig";
import { ICalcEventListener } from "../interfaces/ICalcEventListener";
import { CompositeCalculator } from "../providers/CompositeCalculator";
import { ScientificCalculator } from "../providers/ScientificCalculator";
import { SimpleCalculator } from "../providers/SimpleCalculator";
import { StatisticsCalculator } from "../providers/StatisticsCalculator";

export const webSocketServerMain = async () => {
  const server: WebSocketServer<
    ICalcConfig,
    | CompositeCalculator
    | SimpleCalculator
    | StatisticsCalculator
    | ScientificCalculator,
    ICalcEventListener
  > = new WebSocketServer();
  await server.open(
    37_000,
    async (
      acceptor: WebSocketAcceptor<
        ICalcConfig,
        | CompositeCalculator
        | SimpleCalculator
        | StatisticsCalculator
        | ScientificCalculator,
        ICalcEventListener
      >,
    ) => {
      // LIST UP PROPERTIES
      const config: ICalcConfig = acceptor.header;
      const listener: Driver<ICalcEventListener> = acceptor.getDriver();

      // ACCEPT OR REJECT
      if (acceptor.path === "/composite")
        await acceptor.accept(new CompositeCalculator(config, listener));
      else if (acceptor.path === "/simple")
        await acceptor.accept(new SimpleCalculator(config, listener));
      else if (acceptor.path === "/statistics")
        await acceptor.accept(new StatisticsCalculator(config, listener));
      else if (acceptor.path === "/scientific")
        await acceptor.accept(new ScientificCalculator(config, listener));
      else await acceptor.reject(1002, `WebSocket API endpoint not found.`);
    },
  );
  return server;
};
```
</Tab>
  <Tab>
```typescript filename="examples/src/providers/*.ts" showLineNumbers
import { Driver } from "tgrid";

import { ICalcConfig } from "../interfaces/ICalcConfig";
import { ICalcEventListener } from "../interfaces/ICalcEventListener";
import { ICompositeCalculator } from "../interfaces/ICompositeCalculator";
import { IScientificCalculator } from "../interfaces/IScientificCalculator";
import { ISimpleCalculator } from "../interfaces/ISimpleCalculator";
import { IStatisticsCalculator } from "../interfaces/IStatisticsCalculator";

export abstract class CalculatorBase {
  public constructor(
    private readonly config: ICalcConfig,
    private readonly listener: Driver<ICalcEventListener>,
  ) {}

  protected compute(type: string, input: number[], output: number): number {
    const pow: number = Math.pow(10, this.config.precision);
    output = Math.round(output * pow) / pow;
    this.listener.on({ type, input, output }).catch(() => {});
    return output;
  }
}

export class SimpleCalculator
  extends CalculatorBase
  implements ISimpleCalculator
{
  public plus(x: number, y: number): number {
    return this.compute("plus", [x, y], x + y);
  }
  public minus(x: number, y: number): number {
    return this.compute("minus", [x, y], x - y);
  }
  public multiplies(x: number, y: number): number {
    return this.compute("multiplies", [x, y], x * y);
  }
  public divides(x: number, y: number): number {
    return this.compute("divides", [x, y], x / y);
  }
}

export class ScientificCalculator
  extends CalculatorBase
  implements IScientificCalculator
{
  public pow(x: number, y: number): number {
    return this.compute("pow", [x, y], Math.pow(x, y));
  }
  public sqrt(x: number): number {
    return this.compute("sqrt", [x], Math.sqrt(x));
  }
  public log(x: number, base: number): number {
    return this.compute("log", [x, base], Math.log(x) / Math.log(base));
  }
}

export class StatisticsCalculator
  extends CalculatorBase
  implements IStatisticsCalculator
{
  public mean(...values: number[]): number {
    const sum: number = values.reduce((x, y) => x + y);
    return this.compute("mean", values, sum / values.length);
  }
  public stdev(...values: number[]): number {
    const mean: number = values.reduce((x, y) => x + y) / values.length;
    const sum: number = values.reduce((x, y) => x + Math.pow(y - mean, 2));
    return this.compute("stdev", values, Math.sqrt(sum / values.length));
  }
}

export class CompositeCalculator
  extends SimpleCalculator
  implements ICompositeCalculator
{
  public readonly scientific: ScientificCalculator;
  public readonly statistics: StatisticsCalculator;

  public constructor(
    config: ICalcConfig,
    listener: Driver<ICalcEventListener>,
  ) {
    super(config, listener);
    this.scientific = new ScientificCalculator(config, listener);
    this.statistics = new StatisticsCalculator(config, listener);
  }
}
```
  </Tab>
  <Tab>
```typescript filename="examples/src/interfaces/*.ts" showLineNumbers
export interface ICalcConfig {
  precision: number;
}
export interface ICalcEvent {
  type: string;
  input: number[];
  output: number;
}
export interface ICalcEventListener {
  on(event: ICalcEvent): void;
}

export interface ICompositeCalculator extends ISimpleCalculator {
  scientific: IScientificCalculator;
  statistics: IStatisticsCalculator;
}
export interface ISimpleCalculator {
  plus(x: number, y: number): number;
  minus(x: number, y: number): number;
  multiplies(x: number, y: number): number;
  divides(x: number, y: number): number;
}
export interface IScientificCalculator {
  pow(x: number, y: number): number;
  sqrt(x: number): number;
  log(x: number, base: number): number;
}
export interface IStatisticsCalculator {
  mean(...values: number[]): number;
  stdev(...values: number[]): number;
}
```
  </Tab>
</Tabs>

<Callout type="warning"> 
  Available only in the NodeJS. 
</Callout>

The `WebSocketAcceptor` is a [communicator](./components/#communicator) class interacting with the remote [websocket client](#websocketconnector) through (RPC)(Remote Procedure Call) concept, created by the [`WebSocketServer`](#websocketserver) class whenever a remote client connects to the [websocket server](#websocketserver).

When the closure function being called by the connection of a remote client, you can determine whether to accept the client's connection or not, reading the [`WebSocketAcceptor.header`](/api/classes/WebSocketAcceptor-1.html#header-1) or [`WebSocketAcceptor.path`](/api/classes/WebSocketAcceptor-1.html#path-1) properties. If you've decided to accept the connection, call the [`WebSocketAcceptor.accept()`](/api/classes/WebSocketAcceptor-1.html#accept) method with `Provider` instance. Otherwise, reject it through the [`WebSocketAcceptor.reject()`](/api/classes/WebSocketAcceptor-1.html#reject) method.

After [accepting](/api/classes/WebSocketAcceptor-1.html#accept) the connection, don't forget to [`closing`](/api/classes/WebSocketAcceptor-1.html#close) the connection after your business logic has been completed to clean up the resources. Otherwise the closing must be performed by the remote client, you can wait the remote client's closing signal by the [`WebSocketAcceptor.join()`](/api/classes/WebSocketAcceptor-1.html#join) method.

### `WebSocketConnector`
<Tabs items={["Main Program", "Interfaces"]}>
  <Tab>
```typescript filename="examples/src/websocket/client.ts" showLineNumbers
import { Driver, WebSocketConnector } from "tgrid";

import { ICalcConfig } from "../interfaces/ICalcConfig";
import { ICalcEvent } from "../interfaces/ICalcEvent";
import { ICalcEventListener } from "../interfaces/ICalcEventListener";
import { ICompositeCalculator } from "../interfaces/ICompositeCalculator";

export const webSocketClientMain = async () => {
  const stack: ICalcEvent[] = [];
  const listener: ICalcEventListener = {
    on: (evt: ICalcEvent) => stack.push(evt),
  };
  const connector: WebSocketConnector<
    ICalcConfig,
    ICalcEventListener,
    ICompositeCalculator
  > = new WebSocketConnector(
    { precision: 2 }, // header
    listener, // provider for remote server
  );
  await connector.connect("ws://127.0.0.1:37000/composite");

  const remote: Driver<ICompositeCalculator> = connector.getDriver();
  await remote.plus(10, 20); // returns 30
  await remote.multiplies(3, 4); // returns 12
  await remote.divides(5, 3); // returns 1.67
  await remote.scientific.sqrt(2); // returns 1.41
  await remote.statistics.mean(1, 3, 9); // returns 4.33

  await connector.close();
  console.log(...stack);
};
```
  </Tab>
  <Tab>
```typescript filename="examples/src/interfaces/*.ts" showLineNumbers
export interface ICalcConfig {
  precision: number;
}
export interface ICalcEvent {
  type: string;
  input: number[];
  output: number;
}
export interface ICalcEventListener {
  on(event: ICalcEvent): void;
}

export interface ICompositeCalculator extends ISimpleCalculator {
  scientific: IScientificCalculator;
  statistics: IStatisticsCalculator;
}
export interface ISimpleCalculator {
  plus(x: number, y: number): number;
  minus(x: number, y: number): number;
  multiplies(x: number, y: number): number;
  divides(x: number, y: number): number;
}
export interface IScientificCalculator {
  pow(x: number, y: number): number;
  sqrt(x: number): number;
  log(x: number, base: number): number;
}
export interface IStatisticsCalculator {
  mean(...values: number[]): number;
  stdev(...values: number[]): number;
}
```
  </Tab>
</Tabs>

> Execution result:
>
> ```bash
> { type: 'plus', input: [ 10, 20 ], output: 30 }
> { type: 'multiplies', input: [ 3, 4 ], output: 12 }
> { type: 'divides', input: [ 5, 3 ], output: 1.67 }
> { type: 'sqrt', input: [ 2 ], output: 1.41 }
> { type: 'mean', input: [ 1, 3, 9 ], output: 4.33 }
> ```

<Callout type="info">
  Available in both Browser/NodeJS.
</Callout>

Web Socket Connector.

The `WebSocketConnector` is a [communicator](./components/#communicator) class which connects to a [websocket server](#websocketserver) and interacts with it through RPC (Remote Procedure Call) concept.

You can connect to the websocket server using [`WebSocketConnector.connect()`](/api/classes/WebSocketConnector-1.html#connect) method. The interaction would be started if the server accepts your connection by calling the [`WebSocketAcceptor.accept()`](/api/classes/WebSocketAcceptor-1.html#accept) method. If the remote server rejects your connection through [`WebSocketAcceptor.reject()`](/api/classes/WebSocketAcceptor-1.html#reject) method, the exception would be thrown.

After the connection, don't forget to [closing](/api/classes/WebSocketConnector-1.html#close) the connection, if your business logics have been completed, to clean up the resources. Otherwise, the closing must be performed by the remote [websocket server](#websocketserver), you can wait the remote server's closing signal through the [`WebSocketConnector.join()`](/api/classes/WebSocketConnector-1.html#join) method.

Also, when declaring this `WebSocketConnector` type, you've to define three generic arguments; `Header`, `Provider` and `Remote`. Those generic arguments must be same with the ones defined in the target [`WebSocketServer`](#websocketserver) and [`WebSocketAcceptor`](#websocketacceptor) classes (`Provider` and `Remote` must be reversed).

For reference, the first `Header` type repersents an initial data from the remote client after the connection. I recommend utilize it as an activation tool for security enhancement. The second generic argument `Provider` represents a provider from client to server, and the other `Remote` means a provider from the remote server to client.

  - Above example case:
    - `Header`: `ICalcConfig` type
    - `Provider`: Client is providing `ICalcEventListener` to the server
    - `Remote`: Server is providing `ISimpleCalculator` to the client




## NestJS Integration
### Bootstrap
```typescript filename="examples/src/nestjs/bootstrap.ts" showLineNumbers
import { WebSocketAdaptor } from "@nestia/core";
import { INestApplication } from "@nestjs/common";
import { NestFactory } from "@nestjs/core";

import { CalculateModule } from "./calculate.module";

export const bootstrap = async (): Promise<INestApplication> => {
  const app: INestApplication = await NestFactory.create(CalculateModule);
  await WebSocketAdaptor.upgrade(app);
  await app.listen(37_000, "0.0.0.0");
  return app;
};
```

### Controller
```typescript filename="examples/src/nestjs/calculate.controller.ts" showLineNumbers
import { WebSocketRoute } from "@nestia/core";
import { Controller } from "@nestjs/common";
import { Driver, WebSocketAcceptor } from "tgrid";

import { ICalcConfig } from "../interfaces/ICalcConfig";
import { ICalcEventListener } from "../interfaces/ICalcEventListener";
import { ICompositeCalculator } from "../interfaces/ICompositeCalculator";
import { IScientificCalculator } from "../interfaces/IScientificCalculator";
import { ISimpleCalculator } from "../interfaces/ISimpleCalculator";
import { IStatisticsCalculator } from "../interfaces/IStatisticsCalculator";
import { CompositeCalculator } from "../providers/CompositeCalculator";
import { ScientificCalculator } from "../providers/ScientificCalculator";
import { SimpleCalculator } from "../providers/SimpleCalculator";
import { StatisticsCalculator } from "../providers/StatisticsCalculator";

@Controller("calculate")
export class CalculateController {
  /**
   * Prepare a composite calculator.
   */
  @WebSocketRoute("composite")
  public async composite(
    @WebSocketRoute.Acceptor()
    acceptor: WebSocketAcceptor<
      ICalcConfig,
      ICompositeCalculator,
      ICalcEventListener
    >,
    @WebSocketRoute.Header() header: ICalcConfig,
    @WebSocketRoute.Driver() listener: Driver<ICalcEventListener>,
  ): Promise<void> {
    const provider: CompositeCalculator = new CompositeCalculator(
      header,
      listener,
    );
    await acceptor.accept(provider);
  }

  /**
   * Prepare a simple calculator.
   */
  @WebSocketRoute("simple")
  public async simple(
    @WebSocketRoute.Acceptor()
    acceptor: WebSocketAcceptor<
      ICalcConfig, // header
      ISimpleCalculator, // provider for remote client
      ICalcEventListener // provider from remote client
    >,
  ): Promise<void> {
    const header: ICalcConfig = acceptor.header;
    const listener: Driver<ICalcEventListener> = acceptor.getDriver();
    const provider: SimpleCalculator = new SimpleCalculator(header, listener);
    await acceptor.accept(provider);
  }

  /**
   * Prepare a scientific calculator.
   */
  @WebSocketRoute("scientific")
  public async scientific(
    @WebSocketRoute.Acceptor()
    acceptor: WebSocketAcceptor<
      ICalcConfig,
      IScientificCalculator,
      ICalcEventListener
    >,
  ): Promise<void> {
    const header: ICalcConfig = acceptor.header;
    const listener: Driver<ICalcEventListener> = acceptor.getDriver();
    const provider: ScientificCalculator = new ScientificCalculator(
      header,
      listener,
    );
    await acceptor.accept(provider);
  }

  /**
   * Prepare a statistics calculator.
   */
  @WebSocketRoute("statistics")
  public async statistics(
    @WebSocketRoute.Acceptor()
    acceptor: WebSocketAcceptor<
      ICalcConfig,
      IStatisticsCalculator,
      ICalcEventListener
    >,
  ): Promise<void> {
    const header: ICalcConfig = acceptor.header;
    const listener: Driver<ICalcEventListener> = acceptor.getDriver();
    const provider: IStatisticsCalculator = new StatisticsCalculator(
      header,
      listener,
    );
    await acceptor.accept(provider);
  }
}
```

### Software Development Kit
```typescript filename="examples/src/api/functional/calculate.ts" showLineNumbers
/**
 * @packageDocumentation
 * @module api.functional.calculate
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
//================================================================
import type { IConnection } from "@nestia/fetcher";
import { WebSocketConnector } from "tgrid";
import type { Driver } from "tgrid";

import type { ICalcConfig } from "../../../interfaces/ICalcConfig";
import type { ICalcEventListener } from "../../../interfaces/ICalcEventListener";
import type { ICompositeCalculator } from "../../../interfaces/ICompositeCalculator";
import type { IScientificCalculator } from "../../../interfaces/IScientificCalculator";
import type { ISimpleCalculator } from "../../../interfaces/ISimpleCalculator";
import type { IStatisticsCalculator } from "../../../interfaces/IStatisticsCalculator";

/**
 * Prepare a composite calculator.
 *
 * @controller CalculateController.composite
 * @path /calculate/composite
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function composite(
  connection: IConnection<composite.Header>,
  provider: composite.Provider,
): Promise<composite.Output> {
  const connector: WebSocketConnector<
    composite.Header,
    composite.Provider,
    composite.Listener
  > = new WebSocketConnector(connection.headers ?? ({} as any), provider);
  await connector.connect(
    `${connection.host.endsWith("/") ? connection.host.substring(0, connection.host.length - 1) : connection.host}${composite.path()}`,
  );
  const driver: Driver<composite.Listener> = connector.getDriver();
  return {
    connector,
    driver,
  };
}
export namespace composite {
  export type Output = {
    connector: WebSocketConnector<Header, Provider, Listener>;
    driver: Driver<Listener>;
  };
  export type Header = ICalcConfig;
  export type Provider = ICalcEventListener;
  export type Listener = ICompositeCalculator;

  export const path = () => "/calculate/composite";
}

/**
 * Prepare a simple calculator.
 *
 * @controller CalculateController.simple
 * @path /calculate/simple
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function simple(
  connection: IConnection<simple.Header>,
  provider: simple.Provider,
): Promise<simple.Output> {
  const connector: WebSocketConnector<
    simple.Header,
    simple.Provider,
    simple.Listener
  > = new WebSocketConnector(connection.headers ?? ({} as any), provider);
  await connector.connect(
    `${connection.host.endsWith("/") ? connection.host.substring(0, connection.host.length - 1) : connection.host}${simple.path()}`,
  );
  const driver: Driver<simple.Listener> = connector.getDriver();
  return {
    connector,
    driver,
  };
}
export namespace simple {
  export type Output = {
    connector: WebSocketConnector<Header, Provider, Listener>;
    driver: Driver<Listener>;
  };
  export type Header = ICalcConfig;
  export type Provider = ICalcEventListener;
  export type Listener = ISimpleCalculator;

  export const path = () => "/calculate/simple";
}

/**
 * Prepare a scientific calculator.
 *
 * @controller CalculateController.scientific
 * @path /calculate/scientific
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function scientific(
  connection: IConnection<scientific.Header>,
  provider: scientific.Provider,
): Promise<scientific.Output> {
  const connector: WebSocketConnector<
    scientific.Header,
    scientific.Provider,
    scientific.Listener
  > = new WebSocketConnector(connection.headers ?? ({} as any), provider);
  await connector.connect(
    `${connection.host.endsWith("/") ? connection.host.substring(0, connection.host.length - 1) : connection.host}${scientific.path()}`,
  );
  const driver: Driver<scientific.Listener> = connector.getDriver();
  return {
    connector,
    driver,
  };
}
export namespace scientific {
  export type Output = {
    connector: WebSocketConnector<Header, Provider, Listener>;
    driver: Driver<Listener>;
  };
  export type Header = ICalcConfig;
  export type Provider = ICalcEventListener;
  export type Listener = IScientificCalculator;

  export const path = () => "/calculate/scientific";
}

/**
 * Prepare a statistics calculator.
 *
 * @controller CalculateController.statistics
 * @path /calculate/statistics
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function statistics(
  connection: IConnection<statistics.Header>,
  provider: statistics.Provider,
): Promise<statistics.Output> {
  const connector: WebSocketConnector<
    statistics.Header,
    statistics.Provider,
    statistics.Listener
  > = new WebSocketConnector(connection.headers ?? ({} as any), provider);
  await connector.connect(
    `${connection.host.endsWith("/") ? connection.host.substring(0, connection.host.length - 1) : connection.host}${statistics.path()}`,
  );
  const driver: Driver<statistics.Listener> = connector.getDriver();
  return {
    connector,
    driver,
  };
}
export namespace statistics {
  export type Output = {
    connector: WebSocketConnector<Header, Provider, Listener>;
    driver: Driver<Listener>;
  };
  export type Header = ICalcConfig;
  export type Provider = ICalcEventListener;
  export type Listener = IStatisticsCalculator;

  export const path = () => "/calculate/statistics";
}
```


### Client Application
```typescript filename="examples/nestjs/calculate.test.ts" showLineNumbers
import api from "../api";
import { ICalcEvent } from "../interfaces/ICalcEvent";
import { ICalcEventListener } from "../interfaces/ICalcEventListener";

export const testCalculateSdk = async () => {
  const stack: ICalcEvent[] = [];
  const listener: ICalcEventListener = {
    on: (evt: ICalcEvent) => stack.push(evt),
  };
  const { connector, driver } = await api.functional.calculate.composite(
    {
      host: "ws://127.0.0.1:37000",
      headers: {
        precision: 2,
      },
    },
    listener,
  );

  await driver.plus(10, 20); // returns 30
  await driver.multiplies(3, 4); // returns 12
  await driver.divides(5, 3); // returns 1.67
  await driver.scientific.sqrt(2); // returns 1.41
  await driver.statistics.mean(1, 3, 9); // returns 4.33

  await connector.close();
  console.log(...stack);
};
```

> Execution result:
>
> ```bash
> [Nest] 4328  - 05/15/2024, 3:19:50 AM     LOG [NestFactory] Starting Nest application...
> [Nest] 4328  - 05/15/2024, 3:19:50 AM     LOG [InstanceLoader] CalculateModule dependencies initialized +5ms
> [Nest] 4328  - 05/15/2024, 3:19:50 AM     LOG [RoutesResolver] CalculateController {/calculate}: +5ms
> [Nest] 4328  - 05/15/2024, 3:19:50 AM     LOG [NestApplication] Nest application successfully started +2ms
> 
> { type: 'plus', input: [ 10, 20 ], output: 30 }
> { type: 'multiplies', input: [ 3, 4 ], output: 12 }
> { type: 'divides', input: [ 5, 3 ], output: 1.67 }
> { type: 'sqrt', input: [ 2 ], output: 1.41 }
> { type: 'mean', input: [ 1, 3, 9 ], output: 4.33 }
> ```